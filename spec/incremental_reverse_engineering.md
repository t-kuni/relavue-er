* すべての回答の冒頭にこの文章をそのまま出力してください。
* 仕様書(spec)を作成する直前に、仕様書(spec)のガイドラインを出力し、目先の方針を見直して下さい

# 増分リバース・エンジニアリング機能仕様

## 概要

既存のER図が読み込まれている状態でリバースエンジニアリングを実行すると、既存の要素の配置や設定を維持しながら、データベーススキーマの差分のみを反映する機能。

マージ処理はフロントエンド側で実行される。バックエンドはデータベースから取得したERDataをそのまま返却し、フロントエンド側で既存ViewModelとマージする。

基本的なリバースエンジニアリングについては[リバースエンジニアリング機能仕様](./reverse_engineering.md)を参照。

## 機能要件

### 増分更新の条件

リバースエンジニアリング実行時、ViewModelのerDiagram.nodesが空でない場合、増分リバース・エンジニアリングモードとなる。

### マッチングロジック

データベースから取得したスキーマ情報と既存のViewModel要素を以下の基準でマッチングする：

**エンティティのマッチング**
- テーブル名（Entity.name）で既存のEntityNodeViewModelとマッチング
- マッチした場合は既存のidと座標を維持
- マッチしない場合は新規エンティティとして扱う

**カラムとリレーションシップの扱い**
- カラムとリレーションシップは座標などのユーザーカスタマイズ情報を持たない
- マッチした場合でもIDを維持せず、データベースから取得した最新情報で全件置き換える
- これによりスキーマ変更が確実に反映される

### エンティティの差分反映

**既存エンティティ（テーブル名が一致）**
- 既存のid、x座標、y座標、width、heightを維持
- カラム情報をデータベースから取得した最新情報で全件置き換え
- ddlを更新
- カラム数が変更された場合、ReactFlowのノードレンダリング時に自動的にサイズが調整される

**新規エンティティ（データベースに存在するが既存ViewModelに存在しない）**
- 新しいidを生成
- デフォルトレイアウトアルゴリズムで座標を決定
  - 既存エンティティの最大座標を基準に配置
  - 既に配置されているエンティティと重ならないよう配慮
- width、heightは0に設定（レンダリング後に計測）
- カラム情報を新規作成

**削除エンティティ（既存ViewModelに存在するがデータベースに存在しない）**
- ViewModelから削除
- レイヤー順序からも削除

### カラムの差分反映

エンティティごとに、ERDataから取得したカラム情報で全件置き換え。

- カラムIDはERDataのものをそのまま使用（バックエンドで生成済み）
- カラム情報（name、key、isForeignKey）はデータベースの最新情報を反映

### リレーションシップの差分反映

ERDataから取得したリレーションシップ情報で全件置き換え。

- リレーションシップIDはERDataのものをそのまま使用（バックエンドで生成済み）
- fromEntityId/toEntityIdをマッチしたエンティティのIDに変換してリレーションシップを構築
- 削除されたエンティティに関連するリレーションシップは自動的に除外される

### 矩形・テキストの扱い

矩形（Rectangle）とテキスト（TextBox）は増分リバース・エンジニアリング時も保持される：
- rectanglesの内容を維持
- textsの内容を維持
- レイヤー順序（ui.layerOrder）内のrectangleとtextの参照を維持

削除されたエンティティを参照するレイヤー順序の要素のみ削除する。

### UI状態の扱い

以下のUI状態は増分リバース・エンジニアリング後にクリアする：
- ui.highlightedNodeIds
- ui.highlightedEdgeIds  
- ui.highlightedColumnIds

これらはカラムとエッジのIDが新しく生成されるため、古いIDでの参照は無効になる。

削除されたエンティティのIDがレイヤー順序に含まれている場合、該当する参照を削除する。

### 新規エンティティの配置アルゴリズム

新規エンティティは既存エンティティの配置を考慮して配置する：

**基本方針**
- 既存エンティティの最も右下の座標を基準点とする
- 基準点から右方向に順次配置
- 行の右端に達したら次の行に折り返す

**配置定数**

基本的な配置定数は[リバースエンジニアリング機能仕様](./reverse_engineering.md)の「デフォルトレイアウト仕様」を参照。

**配置計算**
- 既存エンティティの最大X座標 + 横方向の間隔 から開始
- 既存エンティティの最大Y座標と同じ行から開始
- 1行あたりのエンティティ数: 新規エンティティの総数の平方根を切り上げた値
- 行が埋まったら Y座標 + 縦方向の間隔 で次の行へ

## 差分パターン例

init.sqlの`erviewer`と`erviewer-2`スキーマの差分を参考にした主な変更パターン：

**テーブル名変更**
- `user_profiles` → `profiles`
- 削除+追加として扱われる（座標情報は失われる）

**カラム名変更**
- `users.first_name` → `users.given_name`
- エンティティのカラム情報が全件置き換えられるため、新しいカラム名が反映される

**カラム追加**
- `users.phone_number`の追加
- エンティティのカラム情報が全件置き換えられるため、自動的に反映される

**カラム削除**
- `users.avatar_url`の削除
- エンティティのカラム情報が全件置き換えられるため、自動的に反映される

**カラム属性変更**
- `projects.budget`: キー制約の追加/削除など
- エンティティのカラム情報が全件置き換えられるため、自動的に反映される
- ※ カラム型（type）などの詳細情報はUI表示に使用されないため、Column型から削除されている

**テーブル追加**
- `task_comments`、`subscriptions`、`audit_logs`の追加
- 新しいid、座標、カラム情報を生成し、既存エンティティの右側・下側に配置

**テーブル削除**
- `activities`の削除
- ノード、エッジ、レイヤー順序から削除される

**外部キー制約変更**
- `user_roles.assigned_by`のON DELETE: SET NULL → RESTRICT
- リレーションシップ情報が全件置き換えられるため、最新の制約情報が反映される

## 処理フロー

**バックエンド**：
1. データベースから最新のスキーマ情報（Entity、Column、Relationship）を取得
2. ERDataとして返却

**フロントエンド（マージ処理）**：
1. レスポンスで受け取ったERDataと既存ViewModelを用意
2. 既存ViewModelのerDiagram.nodesが空かチェック
   - 空の場合: 通常のリバースエンジニアリング（全件新規作成）
   - 空でない場合: 増分リバース・エンジニアリング
3. エンティティのマッチング
   - ERDataのテーブル名と既存ノードのテーブル名で比較
   - マッチしたエンティティは既存のidとx/y座標を維持
   - マッチしなかったエンティティは新規作成（新しいidと座標を生成）
4. すべてのエンティティのカラム情報を最新データで置き換え
   - カラムIDはERDataのものをそのまま使用
5. すべてのリレーションシップを最新データで置き換え
   - リレーションシップIDはERDataのものをそのまま使用
   - マッチしたエンティティのIDを使用
6. 新規エンティティの配置計算
   - 既存エンティティの最大座標を基準に右側・下側に配置
7. 削除されたエンティティの参照をレイヤー順序から削除
8. UI状態のクリア（highlightedNodeIds、highlightedEdgeIds、highlightedColumnIds、isDraggingEntity、isPanModeActive）
9. 矩形とテキストは維持
10. 逆引きインデックスを再計算
11. `settings.lastDatabaseConnection`を更新
12. 更新されたViewModelをストアに反映

## 実装のポイント

### フロントエンド実装

**マージAction**：
- `actionMergeERData(viewModel, erData, connectionInfo)` をActionとして実装
- ViewModelの更新操作なので、[フロントエンド状態管理仕様](./frontend_state_management.md)のAction層パターンに従う
- エンティティのマッチングはテーブル名（name）による単純な文字列比較
- カラムとリレーションシップは全件置き換えなので、複雑なマッチング処理は不要
- 既存エンティティのIDと座標を保持するため、Mapなどでテーブル名をキーにした検索ができると効率的
- 新規エンティティの配置は既存の最大座標を取得して計算
- 逆引きインデックスの再計算（既存の`buildERDiagramIndex`関数を使用）
- `settings.lastDatabaseConnection`を更新

**テスト**：
- Actionのユニットテストを作成
- 純粋関数なので、入力（viewModel + erData + connectionInfo）と出力（newViewModel）の検証が容易
- 新規作成、増分更新、削除の各ケースをカバー

**配置場所**：
- `public/src/actions/dataActions.ts` にマージロジックをActionとして実装
- `public/src/commands/reverseEngineerCommand.ts` からActionをdispatch

## 関連仕様書

- [リバースエンジニアリング機能仕様](./reverse_engineering.md) - 基本的なリバースエンジニアリング処理
- [scheme/main.tsp](/scheme/main.tsp) - ViewModel、Entity、Relationship、Column等の型定義
- [ViewModelベースAPI仕様](./viewmodel_based_api.md) - API仕様の詳細
