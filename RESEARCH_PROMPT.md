# リサーチ依頼: セマンティックバージョニングの実装方針

## 何をリサーチするか？

このリポジトリでセマンティックバージョニングによる管理を始めたい。どういう仕組みを用意し、どう運用すればよいか検討してほしい。

### 依頼者から指示された要件

* gitのタグとdockerhubのイメージのタグが対象
* github actionsでビルド + dockerhubへのプッシュを自動化した方がよいか？
* どういうタイミングでどういうタグを付与する必要があるか？
* バージョンの数値の管理を楽にできるソリューションはあるか？（今回のバージョンアップがメジャーバージョンアップなのか、マイナーバージョンアップなのかを指定するだけで勝手に数値を指定してくれる的な仕組みはある？）

## プロジェクトの概要

このプロジェクトは、MySQLデータベースからER図をリバースエンジニアリングし、ブラウザ上で可視化・編集できるWebアプリケーションです。

### 主な機能

1. **リバースエンジニアリング**
   - MySQLデータベースからER図を自動生成
   - 増分リバース対応（既存の配置情報を維持）
   - DDL情報の保持

2. **可視化・編集機能**
   - インタラクティブなER図表示
   - エンティティのドラッグ&ドロップ配置
   - ズーム・パン操作
   - リレーション線の表示（直角ポリライン）
   - ホバー時のハイライト表示

3. **詳細情報表示**
   - エンティティクリックでDDL表示
   - サイドバーでの詳細情報表示
   - プライマリキー・外部キーの視覚的区別

4. **注釈機能**
   - 矩形描画（エンティティのグループ化用）
   - テキスト追加（補足情報記載用）
   - カスタマイズ可能な色・サイズ

5. **データ永続化**
   - ER図データとレイアウト情報の保存
   - インポート・エクスポート機能（JSON形式）
   - Dockerボリュームによる柔軟な保存場所設定

### 技術スタック

- **フロントエンド**: TypeScript + React + React Flow
- **バックエンド**: Node.js 20以上、TypeScript 5.0以上、Express
- **データベース**: MySQL、PostgreSQL
- **デプロイ**: Docker（Dockerイメージ: tkuni83/relavue-er）
- **スキーマ管理**: TypeSpec（scheme/main.tsp）からの型生成
- **フロントエンドビルドツール**: Vite
- **状態管理**: 自前Store + React `useSyncExternalStore`（ライブラリ非依存）

### 現状

- プロトタイピング段階
- MVP（Minimum Viable Product）として機能している
- Dockerイメージとして配布中（docker run --rm --network host tkuni83/relavue-er）
- ポート30033で動作
- GitHubリポジトリ: https://github.com/t-kuni/relavue-er

## 現状の実装に関する情報

### バージョン管理の現状

**package.json**
- 現在のバージョン: `1.0.0`
- パッケージ名: `relavue-er`

**Dockerイメージ**
- DockerHubイメージ名: `tkuni83/relavue-er`
- 現在のバージョン管理方法: 不明（タグ付けのルールが確立されていない）

**Dockerfile**
- ファイル名: `Dockerfile.prod`
- マルチステージビルド（deps -> builder -> runner）
- Node.js 20-alpineベースイメージ
- PostgreSQLクライアントを含む
- ポート30033を公開

**ビルド・デプロイの現状**
- ビルドスクリプト: `npm run build`（backend + frontendをビルド）
- GitHub Actionsのワークフロー: 現在存在しない（手動でビルド・プッシュを実施していると推測される）
- CI/CD: 未整備

**Gitリポジトリ**
- リモートリポジトリ: `git@github.com:t-kuni/relavue-er.git`
- ブランチ: `main`（デフォルトブランチと推測）
- gitタグ: 現在のタグ付けルールが確立されていない

### ビルド情報の管理

プロジェクトには`build-info.json`が存在し、ビルド時の情報を記録しています。

- スクリプト: `scripts/generate-build-info.js`
- 生成されるファイル: `build-info.json`

### テストとCI

- テストフレームワーク: Vitest、Jest
- テストスクリプト:
  - `npm run test`: テスト実行
  - `npm run test:watch`: ウォッチモード
  - `npm run test:all`: lint + format + typecheck + test + test:quality

## リサーチ出力に求める事項

以下の観点について、連番を付けて調査・提案してください：

### 1. セマンティックバージョニングの基本方針

セマンティックバージョニング（Semantic Versioning）の基本ルールと、本プロジェクトへの適用方法について調査してください。

- セマンティックバージョニングの基本原則（MAJOR.MINOR.PATCH）
- 各バージョン番号を上げる基準
- プレリリース版やビルドメタデータの扱い
- Dockerイメージタグとの対応関係

### 2. バージョン番号の自動管理ツール ⚠ 意思決定が必要です

バージョン番号の管理を楽にするツールやソリューションについて調査してください。

**選択肢A**: standard-versionやrelease-pleaseなどの自動バージョニングツール
- メリット: Conventional Commitsに基づいて自動でバージョンを決定できる
- デメリット: コミットメッセージの規約を守る必要がある

**選択肢B**: npmコマンド（npm version major/minor/patch）
- メリット: 追加ツール不要、シンプル
- デメリット: 手動操作が必要、自動化が限定的

**選択肢C**: GitHub Actionsのworkflow_dispatchで手動トリガー + バージョンタイプ選択
- メリット: 手動でバージョンタイプを指定でき、柔軟性が高い
- デメリット: 完全自動化ではない

各選択肢について、具体的なツール名とメジャーバージョンを明記し、メリット・デメリットを提示してください。

### 3. Gitタグの付与方法とタイミング ⚠ 意思決定が必要です

Gitタグをどのタイミングで、どのように付与するかについて調査してください。

**選択肢A**: リリース前に手動でタグを付与し、タグをトリガーにGitHub Actionsでビルド・デプロイ
- メリット: タグとリリースが確実に連動する
- デメリット: 手動操作が必要

**選択肢B**: mainブランチへのマージ時に自動でバージョンを決定し、タグを付与
- メリット: 完全自動化
- デメリット: コミットメッセージ規約への依存度が高い

**選択肢C**: GitHub Actionsのworkflow_dispatchで手動トリガー時にタグを自動付与
- メリット: 手動でリリースタイミングをコントロールできる
- デメリット: 自動化の恩恵が限定的

各選択肢について、具体的な実装方法と運用フローを提示してください。

### 4. DockerHubへのイメージプッシュの自動化 ⚠ 意思決定が必要です

GitHub ActionsでDockerイメージのビルドとDockerHubへのプッシュを自動化すべきかどうか、またその方法について調査してください。

**選択肢A**: GitHub Actionsで完全自動化
- メリット: 手動作業が不要、リリースプロセスが標準化される
- デメリット: GitHub ActionsとDockerHubの連携設定が必要

**選択肢B**: ローカルでビルド・プッシュを継続
- メリット: 設定が不要、既存の運用を維持できる
- デメリット: 手動作業が必要、ヒューマンエラーのリスク

**選択肢A**を選択する場合の具体的な実装方法について以下を提示してください：
- GitHub Actionsのワークフロー例
- DockerHubとの認証設定（GitHub Secrets）
- マルチアーキテクチャビルド（amd64, arm64）の対応方法
- ビルドキャッシュの活用方法

### 5. Dockerイメージのタグ戦略 ⚠ 意思決定が必要です

DockerHubにプッシュする際のタグ戦略について調査してください。

**選択肢A**: バージョン番号のみ（例: `1.2.3`）
- メリット: シンプル
- デメリット: `latest`タグがない場合、ユーザーが最新版を特定しにくい

**選択肢B**: バージョン番号 + `latest`タグ（例: `1.2.3`, `latest`）
- メリット: ユーザーが最新版を簡単に使える
- デメリット: `latest`の管理が必要

**選択肢C**: バージョン番号 + メジャーバージョンタグ + `latest`タグ（例: `1.2.3`, `1`, `latest`）
- メリット: ユーザーがメジャーバージョンを固定しつつ、マイナー・パッチの更新を自動で取得できる
- デメリット: タグ管理が複雑

各選択肢について、具体的な運用方法とメリット・デメリットを提示してください。

### 6. プレリリース版やベータ版の扱い ⚠ 意思決定が必要です

開発中の機能をテストするためのプレリリース版やベータ版をどう扱うかについて調査してください。

**選択肢A**: プレリリースタグを使用（例: `1.2.3-beta.1`）
- メリット: セマンティックバージョニングに準拠
- デメリット: タグ管理が複雑

**選択肢B**: 別のDockerHubタグを使用（例: `dev`, `beta`）
- メリット: シンプル
- デメリット: バージョン番号との対応が不明瞭

**選択肢C**: プレリリース版は作成しない
- メリット: 管理がシンプル
- デメリット: テスト環境でのバージョン管理が難しい

各選択肢について、具体的な運用方法とメリット・デメリットを提示してください。

### 7. CHANGELOGの自動生成 ⚠ 意思決定が必要です

バージョン更新時にCHANGELOGを自動生成すべきかどうか、またその方法について調査してください。

**選択肢A**: 自動生成ツールを使用（例: conventional-changelog）
- メリット: 自動でCHANGELOGが作成される
- デメリット: コミットメッセージ規約への依存度が高い

**選択肢B**: 手動でCHANGELOGを記述
- メリット: 自由度が高い、重要な変更のみを記載できる
- デメリット: 手動作業が必要

**選択肢C**: CHANGELOGを作成しない
- メリット: 管理コストが低い
- デメリット: ユーザーが変更内容を把握しにくい

各選択肢について、具体的な実装方法とメリット・デメリットを提示してください。

### 8. GitHub Releasesの活用 ⚠ 意思決定が必要です

GitHub Releasesを使ってバージョン情報を管理すべきかどうか、またその方法について調査してください。

**選択肢A**: GitHub Releasesを使用し、リリースノートを記載
- メリット: GitHubのUIでバージョン履歴を管理できる
- デメリット: リリースノートの記述が必要

**選択肢B**: Gitタグのみを使用し、GitHub Releasesは使用しない
- メリット: シンプル
- デメリット: ユーザーがリリース情報を把握しにくい

各選択肢について、具体的な実装方法とメリット・デメリットを提示してください。

### 9. 既存のpackage.jsonバージョンとの同期

package.jsonのversionフィールドとGitタグ、Dockerイメージタグをどう同期するかについて調査してください。

- package.jsonのバージョンを更新するタイミング
- バージョン更新の自動化方法
- 3つのバージョン（package.json、Gitタグ、Dockerイメージタグ）の一貫性を保つ方法

### 10. ロールバック戦略

リリース後に問題が発覚した場合のロールバック方法について調査してください。

- Dockerイメージの旧バージョンへの切り戻し方法
- Gitタグの削除や修正の方法
- ユーザーへの影響を最小限にする方法

### 11. 推奨される実装方針の提案

上記のリサーチ結果を踏まえて、本プロジェクトに最適な実装方針を推奨度順に提案してください。

各提案について以下を記載してください：
- バージョン管理ツール（または手動運用）
- Gitタグの付与方法とタイミング
- GitHub Actionsのワークフロー設計
- Dockerイメージのタグ戦略
- CHANGELOG、GitHub Releasesの活用方法
- メリット・デメリット
- 実装の複雑さ（プロトタイピング段階に適しているか）
- 具体的な運用フロー例
